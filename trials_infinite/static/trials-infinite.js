/** Minimalistic implementation of infinite live trials iteration
 *
 * Iteration loop is completely controlled by server.
 * Trials data is generated by server in real-time.
 * Responses are send to server in real-time.
 *
 * Control flow:
 * - notifying server when page started
 * - receiving current/initial state of progress and current trial
 * - requesting next trial (unless already received)
 * - receiving next trial
 * - receiving updated progress
 * - showing the trial
 * - taking response from user
 * - sending response to server
 * - receiving feedback
 * - receiving updated progress
 * - iterating loop or completing page
 *
 * Constants used:
 * - TRIAL_DELAY: delay in ms after trial completed
 *
 * Page vars used:
 * - vars.progress: { completed, terminated, ... }
 * - vars.trial: current trial data from server
 * - vars.response: response, should be provided by ot.completeTrial({ response: ... })
 * - vars.feedback: feedback from server
 *
 * Live comminication:
 * - sending 'start'
 * - receiving 'reset' with current progress and (uncompleted) trial
 * - sending 'next'
 * - receiving 'trial'
 * - sending 'response'
 * - receiving 'feedback'
 * - receiving 'progress' (with 'completed' counter and possibly, 'terminated' flag)
*/

function fadeout() {
    vars.transition = "fadeout";
}

function fadein() {
    vars.transition = "fadein";
}

ot.onStartPage(function () {
    vars.progress = {};

    // inform server about page started
    // expect reply 'init'
    ot.sendLive('start');
});

ot.onLive('reset', function (data) {
    // update any progress values
    vars.progress = data.progress;
    if (data.trial) {
        ot.startTrial(data.trial);
    } else {
        ot.nextIteration();
    }
});

ot.onNextIteration(function() {
    // request next trial
    ot.sendLive('next');
});

ot.onLive('trial', function (data) {
    ot.startTrial(data);
});

ot.onStartTrial(function (trial) {
    // reset trial-related data
    vars.trial = trial;
    vars.response = null;
    vars.feedback = null;

    fadein();

    ot.showDisplays();
    ot.resetInputs();
    ot.enableInputs();
    ot.startTimeMeasurement();
});

ot.onCompleteTrial(function (result) {
    // prevent extra input
    ot.disableInputs();

    // put response on page
    vars.response = result.response;

    // add measured time
    result.time = ot.getTimeMeasurement();

    // send response to server
    ot.sendLive('response', result);
});

// receive feedback from server
ot.onLive('feedback', function (data) {
    // just show the feedback on page
    vars.feedback = data;
});

// receive progress update from server
ot.onLive('progress', function (data) {
    // update progress values
    Object.assign(vars.progress, data);

    if (vars.progress.terminated) {
        ot.completePage();
    } else {
        ot.completeIteration();
    }
});

ot.onCompleteIteration(function () {
    ot.delay(TRIAL_DELAY - FADEOUT_TIME, fadeout);
    ot.delay(TRIAL_DELAY, ot.nextIteration);
});

ot.onLive('failure', function (message) {
    alert(message);
    ot.completePage();
});